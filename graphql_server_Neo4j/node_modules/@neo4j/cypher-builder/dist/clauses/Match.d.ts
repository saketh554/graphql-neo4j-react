import type { CypherEnvironment } from "../Environment";
import { PathAssign } from "../pattern/PathAssign";
import { Pattern } from "../pattern/Pattern";
import type { QuantifiedPath } from "../pattern/quantified-patterns/QuantifiedPath";
import { NodeRef } from "../references/NodeRef";
import { Clause } from "./Clause";
import { WithPathAssign } from "./mixins/WithPathAssign";
import { WithCall } from "./mixins/clauses/WithCall";
import { WithCallProcedure } from "./mixins/clauses/WithCallProcedure";
import { WithCreate } from "./mixins/clauses/WithCreate";
import { WithFinish } from "./mixins/clauses/WithFinish";
import { WithMerge } from "./mixins/clauses/WithMerge";
import { WithReturn } from "./mixins/clauses/WithReturn";
import { WithUnwind } from "./mixins/clauses/WithUnwind";
import { WithWith } from "./mixins/clauses/WithWith";
import { WithDelete } from "./mixins/sub-clauses/WithDelete";
import { WithOrder } from "./mixins/sub-clauses/WithOrder";
import { WithRemove } from "./mixins/sub-clauses/WithRemove";
import { WithSet } from "./mixins/sub-clauses/WithSet";
import { WithWhere } from "./mixins/sub-clauses/WithWhere";
export interface Match extends WithReturn, WithWhere, WithSet, WithWith, WithPathAssign, WithDelete, WithRemove, WithUnwind, WithCreate, WithMerge, WithFinish, WithCallProcedure, WithCall, WithOrder {
}
/**
 * @see [Cypher Documentation](https://neo4j.com/docs/cypher-manual/current/clauses/match/)
 * @category Clauses
 */
export declare class Match extends Clause {
    private readonly pattern;
    private _optional;
    private shortestStatement;
    constructor(pattern: Pattern | QuantifiedPath | PathAssign<Pattern | QuantifiedPath>);
    /** @deprecated Use {@link Pattern} instead of node: `new Cypher.Match(new Cypher.Pattern(node))` */
    constructor(node: NodeRef | Pattern | QuantifiedPath);
    /** Makes the clause an OPTIONAL MATCH
     * @see [Cypher Documentation](https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/)
     * @example
     * ```ts
     * new Cypher.Match(new Node({labels: ["Movie"]})).optional();
     * ```
     * _Cypher:_
     * ```cypher
     * OPTIONAL MATCH (this:Movie)
     * ```
     */
    optional(): this;
    /** Add a {@link Match} clause
     * @see [Cypher Documentation](https://neo4j.com/docs/cypher-manual/current/clauses/match/)
     */
    match(clause: Match): Match;
    match(pattern: Pattern): Match;
    /** @deprecated Use {@link Pattern} instead */
    match(pattern: NodeRef | Pattern): Match;
    /** Add an {@link OptionalMatch} clause
     * @see [Cypher Documentation](https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/)
     */
    optionalMatch(pattern: Pattern): OptionalMatch;
    /** @deprecated Use {@link Pattern} instead */
    optionalMatch(pattern: NodeRef | Pattern): OptionalMatch;
    shortest(k: number): this;
    shortestGroups(k: number): this;
    allShortest(): this;
    any(): this;
    /** @internal */
    getCypher(env: CypherEnvironment): string;
    private getShortestStatement;
}
/**
 * @see [Cypher Documentation](https://neo4j.com/docs/cypher-manual/current/clauses/optional-match/)
 * @category Clauses
 */
export declare class OptionalMatch extends Match {
    constructor(pattern: Pattern);
    /** @deprecated Use a {@link Pattern} instead */
    constructor(pattern: NodeRef | Pattern);
}
