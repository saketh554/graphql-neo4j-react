import type { CypherEnvironment } from "../Environment";
import { WithWhere } from "../clauses/mixins/sub-clauses/WithWhere";
import type { LabelExpr } from "../expressions/labels/label-expressions";
import type { PathVariable } from "../references/Path";
import { Variable } from "../references/Variable";
import type { Expr } from "../types";
import type { LengthOption } from "./PartialPattern";
import { PartialPattern } from "./PartialPattern";
import { PathAssign } from "./PathAssign";
import { PatternElement } from "./PatternElement";
import { QuantifiedPattern, type Quantifier } from "./quantified-patterns/QuantifiedPattern";
export type NodePattern = {
    labels?: string | string[] | LabelExpr;
    properties?: Record<string, Expr>;
};
export type RelationshipPattern = {
    type?: string | LabelExpr;
    properties?: Record<string, Expr>;
    direction?: "left" | "right" | "undirected";
    length?: LengthOption;
};
export interface Pattern extends WithWhere {
}
/** Represents a pattern of a single node or n-relationships to be used in clauses.
 * @see [Cypher Documentation](https://neo4j.com/docs/cypher-manual/current/syntax/patterns/)
 * @group Patterns
 */
export declare class Pattern extends PatternElement {
    private withLabels;
    private withVariable;
    private readonly previous;
    private properties;
    private readonly labels;
    constructor(node: Variable, options?: NodePattern);
    constructor(nodeConfig: NodePattern);
    /** @internal */
    constructor(nodeVariable?: Variable | NodePattern, options?: NodePattern, previous?: PartialPattern);
    /** @deprecated */
    withoutLabels(): this;
    /** @deprecated */
    withoutVariable(): this;
    /** @deprecated Use `properties` field when creating the Pattern: `new Cypher.Pattern({ variable: node, properties: myProperties })` */
    withProperties(properties: Record<string, Expr>): this;
    related(ref?: Variable, options?: RelationshipPattern): PartialPattern;
    related(ref: RelationshipPattern): PartialPattern;
    /** Adds a quantifier to the pattern such as `{1,3}`, to be used as part of a {@link QuantifiedPath} */
    quantifier(quantifier: Quantifier): QuantifiedPattern;
    assignTo(variable: PathVariable): PathAssign<this>;
    /** @deprecated This method won't be available in future versions as variables will not be autogenerated by Patterns anymore. */
    getVariables(): Variable[];
    /**
     * @internal
     */
    getCypher(env: CypherEnvironment): string;
    private getLabelsStr;
}
