"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnectOrCreateAndParams = void 0;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const classes_1 = require("../classes");
const find_conflicting_properties_1 = require("../utils/find-conflicting-properties");
const get_relationship_direction_1 = require("../utils/get-relationship-direction");
const utils_1 = require("../utils/utils");
const check_authentication_1 = require("./authorization/check-authentication");
const create_authorization_after_predicate_1 = require("./authorization/create-authorization-after-predicate");
const create_authorization_before_predicate_1 = require("./authorization/create-authorization-before-predicate");
const parse_where_field_1 = require("./queryAST/factory/parsers/parse-where-field");
const callback_utils_1 = require("./utils/callback-utils");
function createConnectOrCreateAndParams({ input, varName, parentVar, relationField, refNode, node, context, withVars, callbackBucket, }) {
    (0, utils_1.asArray)(input).forEach((connectOrCreateItem) => {
        const conflictingProperties = (0, find_conflicting_properties_1.findConflictingProperties)({
            node: refNode,
            input: connectOrCreateItem.onCreate?.node,
        });
        if (conflictingProperties.length > 0) {
            throw new classes_1.Neo4jGraphQLError(`Conflicting modification of ${conflictingProperties.map((n) => `[[${n}]]`).join(", ")} on type ${refNode.name}`);
        }
    });
    // todo: add create
    (0, check_authentication_1.checkAuthentication)({ context, node, targetOperations: ["CREATE", "CREATE_RELATIONSHIP"] });
    (0, check_authentication_1.checkAuthentication)({ context, node: refNode, targetOperations: ["CREATE", "CREATE_RELATIONSHIP"] });
    const withVarsVariables = withVars.map((name) => new cypher_builder_1.default.NamedVariable(name));
    const statements = (0, utils_1.asArray)(input).map((inputItem, index) => {
        const subqueryBaseName = `${varName}${index}`;
        const result = createConnectOrCreatePartialStatement({
            input: inputItem,
            baseName: subqueryBaseName,
            parentVar,
            relationField,
            refNode,
            node,
            context,
            callbackBucket,
            withVars,
        });
        return result;
    });
    const wrappedQueries = statements.map((statement) => {
        const returnStatement = new cypher_builder_1.default.Return([cypher_builder_1.default.count(new cypher_builder_1.default.Raw("*")), "_"]);
        const subqueryClause = new cypher_builder_1.default.With(...withVarsVariables)
            .call(cypher_builder_1.default.utils.concat(statement, returnStatement))
            .importWith(...withVarsVariables);
        return subqueryClause;
    });
    const query = cypher_builder_1.default.utils.concat(...wrappedQueries);
    return query.build(`${varName}_`);
}
exports.createConnectOrCreateAndParams = createConnectOrCreateAndParams;
function createConnectOrCreatePartialStatement({ input, baseName, parentVar, relationField, refNode, node, context, callbackBucket, withVars, }) {
    let mergeQuery;
    // TODO: connectOrCreate currently doesn't honour field-level authorization - this should be fixed
    const authorizationBeforePredicateReturn = createAuthorizationBeforeConnectOrCreate({
        context,
        sourceNode: node,
        sourceName: parentVar,
        targetNode: refNode,
        targetName: baseName,
    });
    if (authorizationBeforePredicateReturn.predicate) {
        if (authorizationBeforePredicateReturn.preComputedSubqueries) {
            mergeQuery = cypher_builder_1.default.utils.concat(mergeQuery, new cypher_builder_1.default.With("*"), authorizationBeforePredicateReturn.preComputedSubqueries);
        }
        mergeQuery = cypher_builder_1.default.utils.concat(mergeQuery, new cypher_builder_1.default.With("*").where(authorizationBeforePredicateReturn.predicate));
    }
    const mergeCypher = mergeStatement({
        input,
        refNode,
        parentRefNode: node,
        context,
        relationField,
        parentNode: new cypher_builder_1.default.NamedNode(parentVar),
        varName: baseName,
        callbackBucket,
        withVars,
    });
    mergeQuery = cypher_builder_1.default.utils.concat(mergeQuery, mergeCypher);
    const authorizationAfterPredicateReturn = createAuthorizationAfterConnectOrCreate({
        context,
        sourceNode: node,
        sourceName: parentVar,
        targetNode: refNode,
        targetName: baseName,
    });
    if (authorizationAfterPredicateReturn.predicate) {
        if (authorizationAfterPredicateReturn.preComputedSubqueries &&
            !authorizationAfterPredicateReturn.preComputedSubqueries.empty) {
            mergeQuery = cypher_builder_1.default.utils.concat(mergeQuery, new cypher_builder_1.default.With("*"), authorizationAfterPredicateReturn.preComputedSubqueries, new cypher_builder_1.default.With("*").where(authorizationAfterPredicateReturn.predicate));
        }
        else {
            mergeQuery = cypher_builder_1.default.utils.concat(mergeQuery, new cypher_builder_1.default.With("*").where(authorizationAfterPredicateReturn.predicate));
        }
    }
    return mergeQuery;
}
function mergeStatement({ input, refNode, parentRefNode, context, relationField, parentNode, varName, callbackBucket, withVars, }) {
    const whereAttributes = Object.fromEntries(Object.entries(input.where?.node ?? {}).map((whereAttribute) => {
        const { fieldName } = (0, parse_where_field_1.parseWhereField)(whereAttribute[0]);
        return [fieldName, whereAttribute[1]];
    }));
    const whereNodeParameters = getCypherParameters(whereAttributes, refNode);
    const onCreateNodeParameters = getCypherParameters(input.onCreate?.node, refNode);
    const autogeneratedParams = getAutogeneratedParams(refNode);
    const node = new cypher_builder_1.default.NamedNode(varName);
    const nodePattern = new cypher_builder_1.default.Pattern(node, {
        properties: whereNodeParameters,
        labels: refNode.getLabels(context),
    });
    const unsetAutogeneratedParams = (0, utils_1.omitFields)(autogeneratedParams, Object.keys(whereAttributes));
    const callbackFields = getCallbackFields(refNode);
    const callbackParams = callbackFields
        .map((callbackField) => {
        const varNameVariable = new cypher_builder_1.default.NamedVariable(varName);
        return (0, callback_utils_1.addCallbackAndSetParamCypher)(callbackField, varNameVariable, parentNode, callbackBucket, "CREATE", node);
    })
        .filter((tuple) => tuple.length !== 0);
    const rawNodeParams = {
        ...unsetAutogeneratedParams,
        ...onCreateNodeParameters,
    };
    const onCreateParams = Object.entries(rawNodeParams).map(([key, param]) => {
        return [node.property(key), param];
    });
    const merge = new cypher_builder_1.default.Merge(nodePattern).onCreateSet(...onCreateParams, ...callbackParams);
    const relationshipFields = context.relationships.find((x) => x.properties === relationField.properties);
    const autogeneratedRelationshipParams = relationshipFields ? getAutogeneratedParams(relationshipFields) : {};
    const rawOnCreateRelationshipParams = cypher_builder_1.default.utils.toCypherParams(input.onCreate?.edge || {});
    const rawRelationshipParams = {
        ...autogeneratedRelationshipParams,
        ...rawOnCreateRelationshipParams,
    };
    const relationship = new cypher_builder_1.default.Relationship();
    const direction = (0, get_relationship_direction_1.getCypherRelationshipDirection)(relationField);
    const relationshipPattern = new cypher_builder_1.default.Pattern(parentNode)
        .related(relationship, { type: relationField.type, direction })
        .to(node);
    const onCreateRelationshipParams = Object.entries(rawRelationshipParams).map(([key, param]) => {
        return [relationship.property(key), param];
    });
    const relationshipMerge = new cypher_builder_1.default.Merge(relationshipPattern).onCreate(...onCreateRelationshipParams);
    let withClause;
    return cypher_builder_1.default.utils.concat(merge, relationshipMerge, withClause);
}
function createAuthorizationBeforeConnectOrCreate({ context, sourceNode, sourceName, }) {
    const predicates = [];
    let subqueries;
    const sourceAuthorizationBefore = (0, create_authorization_before_predicate_1.createAuthorizationBeforePredicate)({
        context,
        nodes: [
            {
                node: sourceNode,
                variable: new cypher_builder_1.default.NamedNode(sourceName),
            },
        ],
        operations: ["CREATE_RELATIONSHIP"],
    });
    if (sourceAuthorizationBefore) {
        const { predicate, preComputedSubqueries } = sourceAuthorizationBefore;
        if (predicate) {
            predicates.push(predicate);
        }
        if (preComputedSubqueries) {
            subqueries = cypher_builder_1.default.utils.concat(subqueries, preComputedSubqueries);
        }
    }
    return {
        predicate: cypher_builder_1.default.and(...predicates),
        preComputedSubqueries: subqueries,
    };
}
function createAuthorizationAfterConnectOrCreate({ context, sourceNode, sourceName, targetNode, targetName, }) {
    const predicates = [];
    let subqueries;
    const sourceAuthorizationAfter = (0, create_authorization_after_predicate_1.createAuthorizationAfterPredicate)({
        context,
        nodes: [
            {
                node: sourceNode,
                variable: new cypher_builder_1.default.NamedNode(sourceName),
            },
        ],
        operations: ["CREATE_RELATIONSHIP"],
    });
    const targetAuthorizationAfter = (0, create_authorization_after_predicate_1.createAuthorizationAfterPredicate)({
        context,
        nodes: [
            {
                node: targetNode,
                variable: new cypher_builder_1.default.NamedNode(targetName),
            },
        ],
        operations: ["CREATE_RELATIONSHIP", "CREATE"],
    });
    if (sourceAuthorizationAfter) {
        const { predicate, preComputedSubqueries } = sourceAuthorizationAfter;
        if (predicate) {
            predicates.push(predicate);
        }
        if (preComputedSubqueries) {
            subqueries = cypher_builder_1.default.utils.concat(subqueries, preComputedSubqueries);
        }
    }
    if (targetAuthorizationAfter) {
        const { predicate, preComputedSubqueries } = targetAuthorizationAfter;
        if (predicate) {
            predicates.push(predicate);
        }
        if (preComputedSubqueries) {
            subqueries = cypher_builder_1.default.utils.concat(subqueries, preComputedSubqueries);
        }
    }
    return {
        predicate: cypher_builder_1.default.and(...predicates),
        preComputedSubqueries: subqueries,
    };
}
function getCallbackFields(node) {
    const callbackFields = [
        ...node.primitiveFields.filter((f) => f.callback),
        ...node.temporalFields.filter((f) => f.callback),
    ];
    return callbackFields;
}
// Helper for compatibility reasons
function getAutogeneratedParams(node) {
    const autogeneratedFields = node.primitiveFields
        .filter((f) => f.autogenerate)
        .reduce((acc, field) => {
        if (field.dbPropertyName) {
            acc[field.dbPropertyName] = new cypher_builder_1.default.Raw("randomUUID()");
        }
        return acc;
    }, {});
    const autogeneratedTemporalFields = node.temporalFields
        .filter((field) => ["DateTime", "Time"].includes(field.typeMeta.name) && field.timestamps?.includes("CREATE"))
        .reduce((acc, field) => {
        if (field.dbPropertyName) {
            acc[field.dbPropertyName] = new cypher_builder_1.default.Raw(`${field.typeMeta.name.toLowerCase()}()`);
        }
        return acc;
    }, {});
    return { ...autogeneratedTemporalFields, ...autogeneratedFields };
}
function getCypherParameters(onCreateParams = {}, node) {
    const params = Object.entries(onCreateParams).reduce((acc, [key, value]) => {
        const nodeField = node?.constrainableFields.find((f) => f.fieldName === key);
        const nodeFieldName = nodeField?.dbPropertyNameUnescaped || nodeField?.fieldName;
        const fieldName = nodeFieldName || key;
        const valueOrArray = nodeField?.typeMeta.array ? (0, utils_1.asArray)(value) : value;
        acc[fieldName] = valueOrArray;
        return acc;
    }, {});
    return cypher_builder_1.default.utils.toCypherParams(params);
}
//# sourceMappingURL=create-connect-or-create-and-params.js.map