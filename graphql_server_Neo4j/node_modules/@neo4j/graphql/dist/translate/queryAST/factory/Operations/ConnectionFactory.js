"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionFactory = void 0;
const utils_1 = require("@graphql-tools/utils");
const graphql_compose_1 = require("graphql-compose");
const graphql_relay_1 = require("graphql-relay");
const neo4j_driver_1 = require("neo4j-driver");
const InterfaceEntity_1 = require("../../../../schema-model/entity/InterfaceEntity");
const ConcreteEntityAdapter_1 = require("../../../../schema-model/entity/model-adapters/ConcreteEntityAdapter");
const check_authentication_1 = require("../../../authorization/check-authentication");
const ConnectionReadOperation_1 = require("../../ast/operations/ConnectionReadOperation");
const CompositeConnectionPartial_1 = require("../../ast/operations/composite/CompositeConnectionPartial");
const CompositeConnectionReadOperation_1 = require("../../ast/operations/composite/CompositeConnectionReadOperation");
const NodeSelection_1 = require("../../ast/selection/NodeSelection");
const RelationshipSelection_1 = require("../../ast/selection/RelationshipSelection");
const get_concrete_entities_1 = require("../../utils/get-concrete-entities");
const get_entity_interfaces_1 = require("../../utils/get-entity-interfaces");
const is_interface_entity_1 = require("../../utils/is-interface-entity");
const is_relationship_entity_1 = require("../../utils/is-relationship-entity");
const is_union_entity_1 = require("../../utils/is-union-entity");
const find_fields_by_name_in_fields_by_type_name_field_1 = require("../parsers/find-fields-by-name-in-fields-by-type-name-field");
const get_fields_by_type_name_1 = require("../parsers/get-fields-by-type-name");
const FulltextFactory_1 = require("./FulltextFactory");
class ConnectionFactory {
    constructor(queryASTFactory) {
        this.queryASTFactory = queryASTFactory;
        this.fulltextFactory = new FulltextFactory_1.FulltextFactory(queryASTFactory);
    }
    createCompositeConnectionOperationAST({ relationship, target, resolveTree, context, }) {
        const directed = resolveTree.args.directed;
        const resolveTreeWhere = this.queryASTFactory.operationsFactory.getWhereArgs(resolveTree);
        let nodeWhere;
        if ((0, is_interface_entity_1.isInterfaceEntity)(target)) {
            nodeWhere = (0, graphql_compose_1.isObject)(resolveTreeWhere) ? resolveTreeWhere.node : {};
        }
        else {
            nodeWhere = resolveTreeWhere;
        }
        const concreteEntities = (0, get_concrete_entities_1.getConcreteEntities)(target, nodeWhere);
        const concreteConnectionOperations = concreteEntities.map((concreteEntity) => {
            let selection;
            let resolveTreeEdgeFields;
            if (relationship) {
                selection = new RelationshipSelection_1.RelationshipSelection({
                    relationship,
                    directed,
                    targetOverride: concreteEntity,
                });
                resolveTreeEdgeFields = this.parseConnectionFields({
                    entityOrRel: relationship,
                    target: concreteEntity,
                    resolveTree,
                });
            }
            else {
                selection = new NodeSelection_1.NodeSelection({
                    target: concreteEntity,
                });
                resolveTreeEdgeFields = this.parseConnectionFields({
                    entityOrRel: concreteEntity,
                    target: concreteEntity,
                    resolveTree,
                });
            }
            const connectionPartial = new CompositeConnectionPartial_1.CompositeConnectionPartial({
                relationship,
                target: concreteEntity,
                selection,
            });
            return this.hydrateConnectionOperationAST({
                relationship,
                target: concreteEntity,
                resolveTree,
                context,
                operation: connectionPartial,
                whereArgs: resolveTreeWhere,
                resolveTreeEdgeFields,
            });
        });
        const compositeConnectionOp = new CompositeConnectionReadOperation_1.CompositeConnectionReadOperation(concreteConnectionOperations);
        // These sort fields will be duplicated on nested "CompositeConnectionPartial"
        this.hydrateConnectionOperationsASTWithSort({
            entityOrRel: relationship ?? target,
            resolveTree,
            operation: compositeConnectionOp,
            context,
        });
        return compositeConnectionOp;
    }
    createConnectionOperationAST({ relationship, target, resolveTree, context, }) {
        if (!(target instanceof ConcreteEntityAdapter_1.ConcreteEntityAdapter)) {
            return this.createCompositeConnectionOperationAST({
                relationship,
                target,
                resolveTree,
                context,
            });
        }
        const resolveTreeWhere = this.queryASTFactory.operationsFactory.getWhereArgs(resolveTree);
        (0, check_authentication_1.checkEntityAuthentication)({
            entity: target.entity,
            targetOperations: ["READ"],
            context,
        });
        let selection;
        let resolveTreeEdgeFields;
        if (relationship) {
            selection = new RelationshipSelection_1.RelationshipSelection({
                relationship,
                directed: resolveTree.args.directed,
            });
            resolveTreeEdgeFields = this.parseConnectionFields({
                entityOrRel: relationship,
                target,
                resolveTree,
            });
        }
        else {
            if (context.resolveTree.args.fulltext || context.resolveTree.args.phrase) {
                selection = this.fulltextFactory.getFulltextSelection(target, context);
            }
            else {
                selection = new NodeSelection_1.NodeSelection({
                    target,
                });
            }
            resolveTreeEdgeFields = this.parseConnectionFields({
                entityOrRel: target,
                target,
                resolveTree,
            });
        }
        const operation = new ConnectionReadOperation_1.ConnectionReadOperation({ relationship, target, selection });
        return this.hydrateConnectionOperationAST({
            relationship,
            target: target,
            resolveTree,
            context,
            operation,
            whereArgs: resolveTreeWhere,
            resolveTreeEdgeFields,
        });
    }
    // eslint-disable-next-line @typescript-eslint/comma-dangle
    hydrateConnectionOperationsASTWithSort({ entityOrRel, resolveTree, operation, context, }) {
        let options;
        const target = (0, is_relationship_entity_1.isRelationshipEntity)(entityOrRel) ? entityOrRel.target : entityOrRel;
        if (!(0, is_union_entity_1.isUnionEntity)(target)) {
            options = this.getConnectionOptions(target, resolveTree.args);
        }
        else {
            options = resolveTree.args;
        }
        const first = options?.first;
        const sort = options?.sort;
        const afterArg = options?.after;
        const offset = (0, graphql_compose_1.isString)(afterArg) ? (0, graphql_relay_1.cursorToOffset)(afterArg) + 1 : undefined;
        if (first || offset) {
            const pagination = this.queryASTFactory.sortAndPaginationFactory.createPagination({
                limit: first,
                offset,
            });
            if (pagination) {
                operation.addPagination(pagination);
            }
        }
        if (sort) {
            sort.forEach((options) => {
                const sort = this.queryASTFactory.sortAndPaginationFactory.createConnectionSortFields(options, entityOrRel, context);
                operation.addSort(sort);
            });
        }
        return operation;
    }
    // The current top-level Connection API is inconsistent with the rest of the API making the parsing more complex than it should be.
    // This function temporary adjust some inconsistencies waiting for the new API.
    // TODO: Remove it when the new API is ready.
    normalizeResolveTreeForTopLevelConnection(resolveTree) {
        const topLevelConnectionResolveTree = Object.assign({}, resolveTree);
        // Move the sort arguments inside a "node" object.
        if (topLevelConnectionResolveTree.args.sort) {
            topLevelConnectionResolveTree.args.sort = resolveTree.args.sort.map((sortField) => {
                return { node: sortField };
            });
        }
        // move the where arguments inside a "node" object.
        if (topLevelConnectionResolveTree.args.where) {
            topLevelConnectionResolveTree.args.where = { node: resolveTree.args.where };
        }
        return topLevelConnectionResolveTree;
    }
    splitConnectionFields(rawFields) {
        let nodeField;
        let edgeField;
        const fields = {};
        Object.entries(rawFields).forEach(([key, field]) => {
            if (field.name === "node") {
                nodeField = field;
            }
            else if (field.name === "edge") {
                edgeField = field;
            }
            else {
                fields[key] = field;
            }
        });
        return {
            node: nodeField,
            edge: edgeField,
            fields,
        };
    }
    getConnectionOptions(entity, options) {
        const limitDirective = entity.annotations.limit;
        let limit = options?.first ?? limitDirective?.default ?? limitDirective?.max;
        if (limit instanceof neo4j_driver_1.Integer) {
            limit = limit.toNumber();
        }
        const maxLimit = limitDirective?.max;
        if (limit !== undefined && maxLimit !== undefined) {
            limit = Math.min(limit, maxLimit);
        }
        if (limit === undefined && options.after === undefined && options.sort === undefined)
            return undefined;
        return {
            first: limit,
            after: options.after,
            sort: options.sort,
        };
    }
    hydrateConnectionOperationAST({ relationship, target, resolveTree, context, operation, whereArgs, resolveTreeEdgeFields, }) {
        const entityOrRel = relationship ?? target;
        const nodeFieldsRaw = (0, find_fields_by_name_in_fields_by_type_name_field_1.findFieldsByNameInFieldsByTypeNameField)(resolveTreeEdgeFields, "node");
        const propertiesFieldsRaw = (0, find_fields_by_name_in_fields_by_type_name_field_1.findFieldsByNameInFieldsByTypeNameField)(resolveTreeEdgeFields, "properties");
        this.hydrateConnectionOperationsASTWithSort({
            entityOrRel,
            resolveTree,
            operation,
            context,
        });
        const isTopLevel = !relationship;
        const resolveTreeNodeFieldsTypesNames = [
            target.name,
            ...target.compositeEntities.filter((e) => e instanceof InterfaceEntity_1.InterfaceEntity).map((e) => e.name),
        ];
        if (!isTopLevel) {
            resolveTreeNodeFieldsTypesNames.push(relationship.target.name);
        }
        const resolveTreeNodeFields = (0, get_fields_by_type_name_1.getFieldsByTypeName)(nodeFieldsRaw, resolveTreeNodeFieldsTypesNames);
        const nodeFields = this.queryASTFactory.fieldFactory.createFields(target, resolveTreeNodeFields, context);
        let edgeFields = [];
        if (!isTopLevel && relationship.propertiesTypeName) {
            const resolveTreePropertiesFields = (0, get_fields_by_type_name_1.getFieldsByTypeName)(propertiesFieldsRaw, [
                relationship.propertiesTypeName,
            ]);
            edgeFields = this.queryASTFactory.fieldFactory.createFields(relationship, resolveTreePropertiesFields, context);
        }
        const authFilters = this.queryASTFactory.authorizationFactory.getAuthFilters({
            entity: target,
            operations: ["READ"],
            attributes: this.queryASTFactory.operationsFactory.getSelectedAttributes(target, resolveTreeNodeFields),
            context,
        });
        const filters = this.queryASTFactory.filterFactory.createConnectionPredicates({
            rel: relationship,
            entity: target,
            where: whereArgs,
            context,
        });
        operation.setNodeFields(nodeFields);
        operation.setEdgeFields(edgeFields);
        operation.addFilters(...filters);
        operation.addAuthFilters(...authFilters);
        return operation;
    }
    parseConnectionFields({ target, resolveTree, entityOrRel, }) {
        // Get interfaces of the entity
        const entityInterfaces = (0, get_entity_interfaces_1.getEntityInterfaces)(target);
        const interfacesFields = entityInterfaces.map((interfaceAdapter) => {
            return resolveTree.fieldsByTypeName[interfaceAdapter.operations.connectionFieldTypename] ?? {};
        });
        const concreteProjectionFields = {
            ...(resolveTree.fieldsByTypeName[entityOrRel.operations.connectionFieldTypename] ??
                resolveTree.fieldsByTypeName[entityOrRel.operations.vectorTypeNames.connection]),
        };
        const resolveTreeConnectionFields = (0, utils_1.mergeDeep)([
            ...interfacesFields,
            concreteProjectionFields,
        ]);
        const edgeFieldsRaw = (0, find_fields_by_name_in_fields_by_type_name_field_1.findFieldsByNameInFieldsByTypeNameField)(resolveTreeConnectionFields, "edges");
        const interfacesEdgeFields = entityInterfaces.map((interfaceAdapter) => {
            return (0, get_fields_by_type_name_1.getFieldsByTypeName)(edgeFieldsRaw, `${interfaceAdapter.name}Edge`);
        });
        const concreteEdgeFields = (0, get_fields_by_type_name_1.getFieldsByTypeName)(edgeFieldsRaw, entityOrRel.operations.relationshipFieldTypename);
        return (0, utils_1.mergeDeep)([...interfacesEdgeFields, concreteEdgeFields]);
    }
}
exports.ConnectionFactory = ConnectionFactory;
//# sourceMappingURL=ConnectionFactory.js.map