"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterFactory = void 0;
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const RelationshipAdapter_1 = require("../../../schema-model/relationship/model-adapters/RelationshipAdapter");
const global_ids_1 = require("../../../utils/global-ids");
const utils_1 = require("../../../utils/utils");
const logical_operators_1 = require("../../utils/logical-operators");
const ConnectionFilter_1 = require("../ast/filters/ConnectionFilter");
const Filter_1 = require("../ast/filters/Filter");
const LogicalFilter_1 = require("../ast/filters/LogicalFilter");
const RelationshipFilter_1 = require("../ast/filters/RelationshipFilter");
const AggregationDurationPropertyFilter_1 = require("../ast/filters/aggregation/AggregationDurationPropertyFilter");
const AggregationFilter_1 = require("../ast/filters/aggregation/AggregationFilter");
const AggregationPropertyFilter_1 = require("../ast/filters/aggregation/AggregationPropertyFilter");
const CountFilter_1 = require("../ast/filters/aggregation/CountFilter");
const CypherFilter_1 = require("../ast/filters/property-filters/CypherFilter");
const DurationFilter_1 = require("../ast/filters/property-filters/DurationFilter");
const PointFilter_1 = require("../ast/filters/property-filters/PointFilter");
const PropertyFilter_1 = require("../ast/filters/property-filters/PropertyFilter");
const TypenameFilter_1 = require("../ast/filters/property-filters/TypenameFilter");
const CustomCypherSelection_1 = require("../ast/selection/CustomCypherSelection");
const get_concrete_entities_1 = require("../utils/get-concrete-entities");
const is_concrete_entity_1 = require("../utils/is-concrete-entity");
const is_interface_entity_1 = require("../utils/is-interface-entity");
const is_union_entity_1 = require("../utils/is-union-entity");
const parse_where_field_1 = require("./parsers/parse-where-field");
class FilterFactory {
    constructor(queryASTFactory) {
        this.queryASTFactory = queryASTFactory;
    }
    createConnectionFilter(relationship, where, filterOps) {
        if ((0, is_interface_entity_1.isInterfaceEntity)(relationship.target) &&
            this.isLabelOptimizationForInterfacePossible(where, relationship.target)) {
            const connectionFilter = this.createConnectionFilterTreeNode({
                relationship: relationship,
                target: relationship.target,
                isNot: filterOps.isNot,
                operator: filterOps.operator,
            });
            const filters = this.createConnectionPredicates({ rel: relationship, entity: relationship.target, where });
            connectionFilter.addFilters(filters);
            return (0, utils_1.asArray)(connectionFilter);
        }
        const filteredEntities = (0, get_concrete_entities_1.getConcreteEntities)(relationship.target, where);
        const connectionFilters = [];
        let partialOf;
        if ((0, is_interface_entity_1.isInterfaceEntity)(relationship.target)) {
            partialOf = relationship.target;
        }
        for (const concreteEntity of filteredEntities) {
            const connectionFilter = this.createConnectionFilterTreeNode({
                relationship: relationship,
                target: concreteEntity,
                isNot: filterOps.isNot,
                operator: filterOps.operator,
            });
            const filters = this.createConnectionPredicates({
                rel: relationship,
                entity: concreteEntity,
                where,
                partialOf,
            });
            connectionFilter.addFilters(filters);
            connectionFilters.push(connectionFilter);
        }
        const logicalOp = this.getLogicalOperatorForRelatedNodeFilters(relationship.target, filterOps.operator);
        return this.wrapMultipleFiltersInLogical(connectionFilters, logicalOp);
    }
    createConnectionPredicates({ rel, entity, where, partialOf, context, }) {
        let entityWhere = where;
        if (rel && (0, is_union_entity_1.isUnionEntity)(rel.target) && where[entity.name]) {
            entityWhere = where[entity.name];
        }
        const filters = (0, utils_1.asArray)(entityWhere).flatMap((nestedWhere) => {
            return Object.entries(nestedWhere).flatMap(([key, value]) => {
                if ((0, logical_operators_1.isLogicalOperator)(key)) {
                    const nestedFilters = this.createConnectionPredicates({ rel, entity, where: value, partialOf });
                    return [
                        new LogicalFilter_1.LogicalFilter({
                            operation: key,
                            filters: (0, utils_1.filterTruthy)(nestedFilters),
                        }),
                    ];
                }
                const connectionWhereField = (0, parse_where_field_1.parseConnectionWhereFields)(key);
                if (rel && connectionWhereField.fieldName === "edge") {
                    return this.createEdgeFilters(rel, value);
                }
                if (connectionWhereField.fieldName === "node") {
                    if (partialOf && (0, is_interface_entity_1.isInterfaceEntity)(partialOf) && (0, is_concrete_entity_1.isConcreteEntity)(entity)) {
                        return this.createInterfaceNodeFilters({
                            entity: partialOf,
                            targetEntity: entity,
                            whereFields: value,
                        });
                    }
                    else if ((0, is_interface_entity_1.isInterfaceEntity)(entity)) {
                        return this.createInterfaceNodeFilters({
                            entity,
                            whereFields: value,
                            relationship: rel,
                        });
                    }
                    return this.createNodeFilters(entity, value, context);
                }
            });
        });
        return (0, utils_1.filterTruthy)(filters);
    }
    createPropertyFilter({ attribute, relationship, comparisonValue, operator, isNot, attachedTo, }) {
        const filterOperator = operator ?? "EQ";
        if (attribute.annotations.cypher) {
            const selection = new CustomCypherSelection_1.CustomCypherSelection({
                operationField: attribute,
                rawArguments: {},
                isNested: true,
            });
            const comparisonValueParam = new cypher_builder_1.default.Param(comparisonValue);
            return new CypherFilter_1.CypherFilter({
                selection,
                attribute,
                comparisonValue: comparisonValueParam,
                operator: filterOperator,
            });
        }
        if (attribute.typeHelper.isDuration()) {
            return new DurationFilter_1.DurationFilter({
                attribute,
                comparisonValue,
                isNot,
                operator: filterOperator,
                attachedTo,
            });
        }
        if (attribute.typeHelper.isPoint() || attribute.typeHelper.isCartesianPoint()) {
            return new PointFilter_1.PointFilter({
                attribute,
                comparisonValue,
                isNot,
                operator: filterOperator,
                attachedTo,
            });
        }
        return new PropertyFilter_1.PropertyFilter({
            attribute,
            relationship,
            comparisonValue,
            isNot,
            operator: filterOperator,
            attachedTo,
        });
    }
    createRelationshipFilter(relationship, where, filterOps, context) {
        /**
         * The logic below can be confusing, but it's to handle the following cases:
         * 1. where: { actors: null } -> in this case we want to return an Exists filter as showed by tests packages/graphql/tests/tck/null.test.ts
         * 2. where: {} -> in this case we want to not apply any filter, as showed by tests packages/graphql/tests/tck/issues/402.test.ts
         **/
        const isNull = where === null;
        if (!isNull && Object.keys(where).length === 0) {
            return [];
        }
        // this is because if isNull is true we want to wrap the Exist subclause in a NOT, but if isNull is true and isNot is true they negate each other
        const isNot = isNull ? !filterOps.isNot : filterOps.isNot;
        const filteredEntities = (0, get_concrete_entities_1.getConcreteEntities)(relationship.target, where);
        const relationshipFilters = [];
        for (const concreteEntity of filteredEntities) {
            const relationshipFilter = this.createRelationshipFilterTreeNode({
                relationship,
                target: concreteEntity,
                isNot,
                operator: filterOps.operator || "SOME",
            });
            if (!isNull) {
                const entityWhere = where[concreteEntity.name] ?? where;
                const targetNodeFilters = this.createNodeFilters(concreteEntity, entityWhere, context);
                relationshipFilter.addTargetNodeFilter(...targetNodeFilters);
            }
            relationshipFilters.push(relationshipFilter);
        }
        const logicalOp = this.getLogicalOperatorForRelatedNodeFilters(relationship.target, filterOps.operator);
        return this.wrapMultipleFiltersInLogical(relationshipFilters, logicalOp);
    }
    // This allows to override this creation in AuthorizationFilterFactory
    createRelationshipFilterTreeNode(options) {
        return new RelationshipFilter_1.RelationshipFilter(options);
    }
    // This allows to override this creation in AuthorizationFilterFactory
    createConnectionFilterTreeNode(options) {
        return new ConnectionFilter_1.ConnectionFilter(options);
    }
    createInterfaceNodeFilters({ entity, targetEntity, whereFields, relationship, context, }) {
        const filters = (0, utils_1.filterTruthy)(Object.entries(whereFields).flatMap(([key, value]) => {
            const valueAsArray = (0, utils_1.asArray)(value);
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const nestedFilters = valueAsArray.flatMap((nestedWhere) => {
                    return this.createInterfaceNodeFilters({ entity, targetEntity, whereFields: nestedWhere });
                });
                return new LogicalFilter_1.LogicalFilter({
                    operation: key,
                    filters: nestedFilters,
                });
            }
            if (key === "typename_IN") {
                const acceptedEntities = entity.concreteEntities.filter((concreteEntity) => {
                    return valueAsArray.some((typenameFilterValue) => typenameFilterValue === concreteEntity.name);
                });
                return new TypenameFilter_1.TypenameFilter(acceptedEntities);
            }
            const { fieldName, operator, isNot, isConnection, isAggregate } = (0, parse_where_field_1.parseWhereField)(key);
            const relationshipDeclaration = entity.findRelationshipDeclarations(fieldName);
            if (targetEntity && relationshipDeclaration) {
                const relationship = relationshipDeclaration.relationshipImplementations.find((r) => r.source.name === targetEntity.name);
                if (!relationship) {
                    throw new Error(`Relationship ${fieldName} not found`);
                }
                return this.createRelatedNodeFilters({
                    relationship,
                    value,
                    operator,
                    isNot,
                    isConnection,
                    isAggregate,
                    context,
                });
            }
            const attr = entity.findAttribute(fieldName);
            if (!attr) {
                throw new Error(`Attribute ${fieldName} not found`);
            }
            return this.createPropertyFilter({
                attribute: attr,
                relationship,
                comparisonValue: value,
                isNot,
                operator,
            });
        }));
        return this.wrapMultipleFiltersInLogical(filters);
    }
    createNodeFilters(entity, whereFields, context) {
        if ((0, is_union_entity_1.isUnionEntity)(entity)) {
            return [];
        }
        const filters = (0, utils_1.filterTruthy)(Object.entries(whereFields).flatMap(([key, value]) => {
            const valueAsArray = (0, utils_1.asArray)(value);
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const nestedFilters = valueAsArray.flatMap((nestedWhere) => {
                    return this.createNodeFilters(entity, nestedWhere, context);
                });
                return new LogicalFilter_1.LogicalFilter({
                    operation: key,
                    filters: nestedFilters,
                });
            }
            const { fieldName, operator, isNot, isConnection, isAggregate } = (0, parse_where_field_1.parseWhereField)(key);
            const relationship = entity.findRelationship(fieldName);
            if (relationship) {
                return this.createRelatedNodeFilters({
                    relationship,
                    value,
                    operator,
                    isNot,
                    isConnection,
                    isAggregate,
                });
            }
            const attr = entity.findAttribute(fieldName);
            if (!attr) {
                if (fieldName === "id" && entity.globalIdField) {
                    return this.createRelayIdPropertyFilter(entity, isNot, operator, value);
                }
                throw new Error(`Attribute ${fieldName} not found`);
            }
            return this.createPropertyFilter({
                attribute: attr,
                comparisonValue: value,
                isNot,
                operator,
            });
        }));
        return this.wrapMultipleFiltersInLogical(filters);
    }
    createRelatedNodeFilters({ relationship, value, operator, isNot, isConnection, isAggregate, context, }) {
        if (isAggregate) {
            return this.createAggregationFilter(relationship, value);
        }
        if (operator && !(0, Filter_1.isRelationshipOperator)(operator)) {
            throw new Error(`Invalid operator ${operator} for relationship`);
        }
        if (isConnection) {
            return this.createConnectionFilter(relationship, value, {
                isNot,
                operator,
            });
        }
        return this.createRelationshipFilter(relationship, value, {
            isNot,
            operator,
        }, context);
    }
    getLogicalOperatorForRelatedNodeFilters(target, operator = "SOME") {
        if ((0, is_interface_entity_1.isInterfaceEntity)(target)) {
            if (operator === "SOME") {
                return "OR";
            }
            if (operator === "SINGLE") {
                return "XOR";
            }
        }
        return "AND";
    }
    createRelayIdPropertyFilter(entity, isNot, operator, value) {
        const relayIdData = (0, global_ids_1.fromGlobalId)(value);
        const { typeName, field } = relayIdData;
        let id = relayIdData.id;
        if (typeName !== entity.name || !field || !id) {
            throw new Error(`Cannot query Relay Id on "${entity.name}"`);
        }
        const idAttribute = entity.findAttribute(field);
        if (!idAttribute) {
            throw new Error(`Attribute ${field} not found`);
        }
        if (idAttribute.typeHelper.isNumeric()) {
            id = Number(id);
            if (Number.isNaN(id)) {
                throw new Error("Can't parse non-numeric relay id");
            }
        }
        return this.createPropertyFilter({
            attribute: idAttribute,
            comparisonValue: id,
            isNot,
            operator,
        });
    }
    createEdgeFilters(relationship, where) {
        const filterASTs = Object.entries(where).flatMap(([key, value]) => {
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const nestedFilters = (0, utils_1.asArray)(value).flatMap((nestedWhere) => {
                    return this.createEdgeFilters(relationship, nestedWhere);
                });
                return new LogicalFilter_1.LogicalFilter({
                    operation: key,
                    filters: nestedFilters,
                });
            }
            const { fieldName, operator, isNot } = (0, parse_where_field_1.parseWhereField)(key);
            const attribute = relationship.findAttribute(fieldName);
            if (!attribute) {
                if (fieldName === relationship.propertiesTypeName) {
                    return this.createEdgeFilters(relationship, value);
                }
                return;
            }
            return this.createPropertyFilter({
                attribute,
                comparisonValue: value,
                isNot,
                operator,
                attachedTo: "relationship",
            });
        });
        return this.wrapMultipleFiltersInLogical((0, utils_1.filterTruthy)(filterASTs));
    }
    getAggregationNestedFilters(where, relationship) {
        const nestedFilters = Object.entries(where).flatMap(([key, value]) => {
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                const nestedFilters = (0, utils_1.asArray)(value).flatMap((nestedWhere) => {
                    return this.getAggregationNestedFilters(nestedWhere, relationship);
                });
                const logicalFilter = new LogicalFilter_1.LogicalFilter({
                    operation: key,
                    filters: nestedFilters,
                });
                return [logicalFilter];
            }
            const { fieldName, operator, isNot } = (0, parse_where_field_1.parseWhereField)(key);
            const filterOperator = operator ?? "EQ";
            if (fieldName === "count") {
                const countFilter = new CountFilter_1.CountFilter({
                    operator: filterOperator,
                    isNot,
                    comparisonValue: value,
                });
                return [countFilter];
            }
            if (fieldName === "node") {
                return this.createAggregationNodeFilters(value, relationship.target, relationship);
            }
            if (fieldName === "edge") {
                return this.createAggregationNodeFilters(value, relationship);
            }
            throw new Error(`Aggregation filter not found ${key}`);
        });
        return this.wrapMultipleFiltersInLogical(nestedFilters);
    }
    createAggregationFilter(relationship, where) {
        const aggregationFilter = new AggregationFilter_1.AggregationFilter(relationship);
        const nestedFilters = this.getAggregationNestedFilters(where, relationship);
        aggregationFilter.addFilters(...nestedFilters);
        return aggregationFilter;
    }
    createAggregationNodeFilters(where, entity, relationship) {
        const filters = Object.entries(where).map(([key, value]) => {
            if ((0, logical_operators_1.isLogicalOperator)(key)) {
                return this.createAggregateLogicalFilter(key, value, entity, relationship);
            }
            // NOTE: if aggregationOperator is undefined, maybe we could return a normal PropertyFilter instead
            const { fieldName, logicalOperator, aggregationOperator } = (0, parse_where_field_1.parseAggregationWhereFields)(key);
            const attr = entity.findAttribute(fieldName);
            if (!attr)
                throw new Error(`Attribute ${fieldName} not found`);
            const attachedTo = entity instanceof RelationshipAdapter_1.RelationshipAdapter ? "relationship" : "node";
            if (attr.typeHelper.isDuration()) {
                return new AggregationDurationPropertyFilter_1.AggregationDurationFilter({
                    attribute: attr,
                    comparisonValue: value,
                    logicalOperator: logicalOperator || "EQUAL",
                    aggregationOperator: aggregationOperator,
                    attachedTo,
                });
            }
            return new AggregationPropertyFilter_1.AggregationPropertyFilter({
                attribute: attr,
                relationship,
                comparisonValue: value,
                logicalOperator: logicalOperator || "EQUAL",
                aggregationOperator: aggregationOperator,
                attachedTo,
            });
        });
        return this.wrapMultipleFiltersInLogical(filters);
    }
    /** Returns an array of 0 or 1 elements with the filters wrapped using a logical operator if needed */
    wrapMultipleFiltersInLogical(filters, logicalOp = "AND") {
        if (filters.length > 1) {
            return [
                new LogicalFilter_1.LogicalFilter({
                    operation: logicalOp,
                    filters,
                }),
            ];
        }
        const singleFilter = filters[0];
        if (singleFilter) {
            return [singleFilter];
        }
        return [];
    }
    createAggregateLogicalFilter(operation, where, entity, relationship) {
        const filters = (0, utils_1.asArray)(where).flatMap((nestedWhere) => {
            return this.createAggregationNodeFilters(nestedWhere, entity, relationship);
        });
        return new LogicalFilter_1.LogicalFilter({
            operation,
            filters,
        });
    }
    // This method identifies if it's possible to achieve MATCH (n)-[r]->(m) WHERE m:Movie Or m:Series rather than MATCH (n)-[r]->(m:Movie) Or MATCH (n)-[r]->(m:Series)
    // When filters contain a nested relationship filter this is no longer achievable as the relationship definition is not shared between each concrete entity.
    // For context check TCK test packages/graphql/tests/tck/issues/2709.test.ts --> "should not use a node label so it covers all nodes implementing the interface for connection rel".
    isLabelOptimizationForInterfacePossible(where, entity) {
        if (where.node) {
            const containsUnoptimizableFields = Object.keys(where.node).some((field) => {
                const { fieldName, isAggregate, isConnection } = (0, parse_where_field_1.parseWhereField)(field);
                if (isAggregate || isConnection) {
                    return true;
                }
                const relationshipDeclaration = entity.findRelationshipDeclarations(fieldName);
                if (relationshipDeclaration) {
                    return true;
                }
                return false;
            });
            return !containsUnoptimizableFields;
        }
        return true;
    }
}
exports.FilterFactory = FilterFactory;
//# sourceMappingURL=FilterFactory.js.map