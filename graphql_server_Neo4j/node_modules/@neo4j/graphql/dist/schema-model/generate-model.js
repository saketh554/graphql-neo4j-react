"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateModel = void 0;
const classes_1 = require("../classes");
const library_directives_1 = require("./library-directives");
const directives_1 = require("../graphql/directives");
const get_field_type_meta_1 = __importDefault(require("../schema/get-field-type-meta"));
const utils_1 = require("../utils/utils");
const Neo4jGraphQLSchemaModel_1 = require("./Neo4jGraphQLSchemaModel");
const Operation_1 = require("./Operation");
const ConcreteEntity_1 = require("./entity/ConcreteEntity");
const InterfaceEntity_1 = require("./entity/InterfaceEntity");
const UnionEntity_1 = require("./entity/UnionEntity");
const definition_collection_1 = require("./parser/definition-collection");
const parse_annotation_1 = require("./parser/parse-annotation");
const parse_arguments_1 = require("./parser/parse-arguments");
const parse_attribute_1 = require("./parser/parse-attribute");
const utils_2 = require("./parser/utils");
const Relationship_1 = require("./relationship/Relationship");
const is_in_array_1 = require("../utils/is-in-array");
const RelationshipDeclaration_1 = require("./relationship/RelationshipDeclaration");
const utils_3 = require("../schema/validation/custom-rules/utils/utils");
function generateModel(document) {
    const definitionCollection = (0, definition_collection_1.getDefinitionCollection)(document);
    const operations = definitionCollection.operations.reduce((acc, definition) => {
        acc[definition.name.value] = generateOperation(definition, definitionCollection);
        return acc;
    }, {});
    // hydrate interface to typeNames map
    hydrateInterfacesToTypeNamesMap(definitionCollection);
    const concreteEntities = Array.from(definitionCollection.nodes.values()).map((node) => generateConcreteEntity(node, definitionCollection));
    const concreteEntitiesMap = concreteEntities.reduce((acc, entity) => {
        if (acc.has(entity.name)) {
            throw new classes_1.Neo4jGraphQLSchemaValidationError(`Duplicate node ${entity.name}`);
        }
        acc.set(entity.name, entity);
        return acc;
    }, new Map());
    const interfaceEntities = Array.from(definitionCollection.interfaceToImplementingTypeNamesMap.entries()).map(([name, concreteEntities]) => {
        const interfaceNode = definitionCollection.interfaceTypes.get(name);
        if (!interfaceNode) {
            throw new Error(`Cannot find interface ${name}`);
        }
        return generateInterfaceEntity(name, interfaceNode, concreteEntities, concreteEntitiesMap, definitionCollection);
    });
    const unionEntities = Array.from(definitionCollection.unionTypes).map(([unionName, unionDefinition]) => {
        return generateUnionEntity(unionName, unionDefinition, unionDefinition.types?.map((t) => t.name.value) || [], concreteEntitiesMap);
    });
    const annotations = (0, parse_annotation_1.parseAnnotations)(definitionCollection.schemaDirectives);
    const schema = new Neo4jGraphQLSchemaModel_1.Neo4jGraphQLSchemaModel({
        compositeEntities: [...unionEntities, ...interfaceEntities],
        concreteEntities,
        operations,
        annotations,
    });
    definitionCollection.nodes.forEach((def) => hydrateRelationships(def, schema, definitionCollection));
    definitionCollection.interfaceTypes.forEach((def) => hydrateRelationshipDeclarations(def, schema, definitionCollection));
    addCompositeEntitiesToConcreteEntity(interfaceEntities);
    addCompositeEntitiesToConcreteEntity(unionEntities);
    return schema;
}
exports.generateModel = generateModel;
function addCompositeEntitiesToConcreteEntity(compositeEntities) {
    compositeEntities.forEach((compositeEntity) => {
        compositeEntity.concreteEntities.forEach((concreteEntity) => concreteEntity.addCompositeEntities(compositeEntity));
    });
}
function hydrateInterfacesToTypeNamesMap(definitionCollection) {
    return definitionCollection.nodes.forEach((node) => {
        if (!node.interfaces) {
            return;
        }
        const objectTypeName = node.name.value;
        node.interfaces?.forEach((i) => {
            const interfaceTypeName = i.name.value;
            const concreteEntities = definitionCollection.interfaceToImplementingTypeNamesMap.get(interfaceTypeName);
            if (!concreteEntities) {
                throw new classes_1.Neo4jGraphQLSchemaValidationError(`Could not find composite entity with name ${interfaceTypeName}`);
            }
            // TODO: modify the existing array instead of creating a new one
            definitionCollection.interfaceToImplementingTypeNamesMap.set(interfaceTypeName, concreteEntities.concat(objectTypeName));
        });
    });
}
function generateUnionEntity(entityDefinitionName, unionDefinition, entityImplementingTypeNames, concreteEntities) {
    const unionEntity = generateCompositeEntity(entityDefinitionName, entityImplementingTypeNames, concreteEntities);
    const annotations = (0, parse_annotation_1.parseAnnotations)(unionDefinition.directives || []);
    return new UnionEntity_1.UnionEntity({ ...unionEntity, annotations });
}
function generateInterfaceEntity(entityDefinitionName, definition, entityImplementingTypeNames, concreteEntities, definitionCollection) {
    const interfaceEntity = generateCompositeEntity(entityDefinitionName, entityImplementingTypeNames, concreteEntities);
    const fields = (definition.fields || []).map((fieldDefinition) => {
        const isPrivateAttribute = (0, utils_2.findDirective)(fieldDefinition.directives, directives_1.privateDirective.name);
        if (isPrivateAttribute) {
            return;
        }
        const isRelationshipAttribute = (0, utils_2.findDirective)(fieldDefinition.directives, directives_1.declareRelationshipDirective.name);
        if (isRelationshipAttribute) {
            return;
        }
        return (0, parse_attribute_1.parseAttribute)(fieldDefinition, definitionCollection, definition.fields);
    });
    const annotations = (0, parse_annotation_1.parseAnnotations)(definition.directives || []);
    return new InterfaceEntity_1.InterfaceEntity({
        ...interfaceEntity,
        description: definition.description?.value,
        attributes: (0, utils_1.filterTruthy)(fields),
        annotations,
    });
}
function generateCompositeEntity(entityDefinitionName, entityImplementingTypeNames, concreteEntities) {
    const compositeFields = entityImplementingTypeNames.map((type) => {
        const concreteEntity = concreteEntities.get(type);
        if (!concreteEntity) {
            throw new classes_1.Neo4jGraphQLSchemaValidationError(`Could not find concrete entity with name ${type}`);
        }
        return concreteEntity;
    });
    /*
   // This is commented out because is currently possible to have leaf interfaces as demonstrated in the test
   // packages/graphql/tests/integration/aggregations/where/node/string.int.test.ts
   if (!compositeFields.length) {
        throw new Neo4jGraphQLSchemaValidationError(
            `Composite entity ${entityDefinitionName} has no concrete entities`
        );
    } */
    return {
        name: entityDefinitionName,
        concreteEntities: compositeFields,
    };
}
function hydrateRelationships(definition, schema, definitionCollection) {
    const name = definition.name.value;
    const entity = schema.getEntity(name);
    if (!entity) {
        throw new Error(`Cannot find entity ${name}`);
    }
    if (!(entity instanceof ConcreteEntity_1.ConcreteEntity)) {
        throw new Error(`Can only add relationship to concrete entity and ${name} is not concrete.`);
    }
    if (!definition.fields?.length) {
        return;
    }
    for (const fieldDefinition of definition.fields) {
        const { firstDeclaredInTypeName, originalTarget } = getFirstDeclaration(definition, fieldDefinition.name.value, definitionCollection, schema);
        const relationshipField = generateRelationshipField(fieldDefinition, schema, entity, definitionCollection, firstDeclaredInTypeName, originalTarget);
        if (relationshipField) {
            entity.addRelationship(relationshipField);
        }
    }
}
function hydrateRelationshipDeclarations(definition, schema, definitionCollection) {
    const name = definition.name.value;
    const entity = schema.getEntity(name);
    if (!entity) {
        throw new Error(`Cannot find entity ${name}`);
    }
    if (!(entity instanceof InterfaceEntity_1.InterfaceEntity)) {
        throw new Error(`Can only declare relationships on Interface entities and ${name} is not an Interface.`);
    }
    if (!definition.fields?.length) {
        return;
    }
    for (const fieldDefinition of definition.fields) {
        const { firstDeclaredInTypeName } = getFirstDeclaration(definition, fieldDefinition.name.value, definitionCollection, schema);
        const relationshipField = generateRelationshipDeclaration(fieldDefinition, schema, entity, definitionCollection, firstDeclaredInTypeName);
        if (relationshipField) {
            entity.addRelationshipDeclaration(relationshipField);
            const allImplementationsPropertiesTypeNames = (0, utils_1.filterTruthy)(relationshipField.relationshipImplementations.map((impl) => impl.propertiesTypeName));
            for (const impl of relationshipField.relationshipImplementations) {
                impl.setSiblings(allImplementationsPropertiesTypeNames);
            }
        }
    }
}
function getFieldDeclaredAsRelationship(interfaceDef, fieldName) {
    const fields = interfaceDef?.fields || [];
    return fields.find((field) => field.name.value === fieldName && field.directives?.some((d) => d.name.value === "declareRelationship"));
}
function getDefinitionNodeFromNamedNode(interfaceNamedNode, definitionCollection) {
    const interfaceName = interfaceNamedNode.name.value;
    return definitionCollection.interfaceTypes.get(interfaceName);
}
/**
 * Goes up the inheritance chain checking for the field to have the @relationshipDeclaration directive
 * Finds the first interface that declares the field as a relationship
 * Returns the name of the first interface and the target of the relationship declaration in that first interface
 *
 * @param definition Entity with relationship field (Starting point)
 * @param fieldName Relationship field name (The one we look for first declaration for)
 * @param definitionCollection
 * @param schema
 * @returns Info about the interface at the top of the chain, nullable because there might not be any
 */
function getFirstDeclaration(definition, fieldName, definitionCollection, schema) {
    if (!definition || !definition.interfaces) {
        return {};
    }
    let inheritedInterfaceWithDeclaredField;
    let declaredFieldTypeName;
    for (const interfaceNamedNode of definition.interfaces) {
        const interfaceDef = getDefinitionNodeFromNamedNode(interfaceNamedNode, definitionCollection);
        const declaredRelationshipField = getFieldDeclaredAsRelationship(interfaceDef, fieldName);
        if (declaredRelationshipField) {
            inheritedInterfaceWithDeclaredField = interfaceNamedNode;
            declaredFieldTypeName = (0, utils_3.getInnerTypeName)(declaredRelationshipField.type);
        }
    }
    if (!inheritedInterfaceWithDeclaredField) {
        // definition declares it first
        return {};
    }
    // found implemented interface that declares it
    const currentInChain = {
        originalTarget: schema.getEntity(declaredFieldTypeName || ""),
        firstDeclaredInTypeName: inheritedInterfaceWithDeclaredField.name.value,
    };
    // attempt to go up in chain
    const interfaceDef = getDefinitionNodeFromNamedNode(inheritedInterfaceWithDeclaredField, definitionCollection);
    const prevInChain = getFirstDeclaration(interfaceDef, fieldName, definitionCollection, schema);
    if (prevInChain.firstDeclaredInTypeName) {
        // found interface that declares it up in chain
        return prevInChain;
    }
    // this interface declares it first
    return currentInChain;
}
function generateRelationshipField(field, schema, source, definitionCollection, firstDeclaredInTypeName, originalTarget) {
    // TODO: remove reference to getFieldTypeMeta
    const fieldTypeMeta = (0, get_field_type_meta_1.default)(field.type);
    const relationshipUsage = (0, utils_2.findDirective)(field.directives, "relationship");
    if (!relationshipUsage)
        return undefined;
    const fieldName = field.name.value;
    const relatedEntityName = fieldTypeMeta.name;
    const relatedToEntity = schema.getEntity(relatedEntityName);
    if (!relatedToEntity)
        throw new Error(`Entity ${relatedEntityName} Not Found`);
    const { type, direction, properties, queryDirection, nestedOperations, aggregate } = (0, parse_arguments_1.parseArguments)(directives_1.relationshipDirective, relationshipUsage);
    let attributes = [];
    let propertiesTypeName = undefined;
    if (properties && typeof properties === "string") {
        const propertyInterface = definitionCollection.relationshipProperties.get(properties);
        if (!propertyInterface) {
            throw new Error(`The \`@relationshipProperties\` directive could not be found on the \`${properties}\` interface`);
        }
        propertiesTypeName = properties;
        const fields = (propertyInterface.fields || []).map((fieldDefinition) => {
            const isPrivateAttribute = (0, utils_2.findDirective)(fieldDefinition.directives, directives_1.privateDirective.name);
            if (isPrivateAttribute) {
                return;
            }
            return (0, parse_attribute_1.parseAttribute)(fieldDefinition, definitionCollection, propertyInterface.fields);
        });
        attributes = (0, utils_1.filterTruthy)(fields);
    }
    const annotations = (0, parse_annotation_1.parseAnnotations)(field.directives || []);
    const args = (0, parse_attribute_1.parseAttributeArguments)(field.arguments || [], definitionCollection);
    return new Relationship_1.Relationship({
        name: fieldName,
        type,
        args,
        attributes,
        source,
        target: relatedToEntity,
        direction,
        isList: Boolean(fieldTypeMeta.array),
        queryDirection,
        nestedOperations,
        aggregate,
        isNullable: !fieldTypeMeta.required,
        description: field.description?.value,
        annotations: annotations,
        propertiesTypeName,
        firstDeclaredInTypeName,
        originalTarget,
    });
}
function generateRelationshipDeclaration(field, schema, source, definitionCollection, firstDeclaredInTypeName) {
    // TODO: remove reference to getFieldTypeMeta
    const fieldTypeMeta = (0, get_field_type_meta_1.default)(field.type);
    const declareRelationshipUsage = (0, utils_2.findDirective)(field.directives, "declareRelationship");
    if (!declareRelationshipUsage) {
        return;
    }
    const fieldName = field.name.value;
    const relatedEntityName = fieldTypeMeta.name;
    const relatedToEntity = schema.getEntity(relatedEntityName);
    if (!relatedToEntity) {
        throw new Error(`Entity ${relatedEntityName} Not Found`);
    }
    const { nestedOperations, aggregate } = (0, parse_arguments_1.parseArguments)(directives_1.declareRelationshipDirective, declareRelationshipUsage);
    const annotations = (0, parse_annotation_1.parseAnnotations)(field.directives || []);
    const relationshipImplementations = source.concreteEntities
        .map((concreteEntity) => concreteEntity.findRelationship(fieldName))
        .filter((x) => x);
    return new RelationshipDeclaration_1.RelationshipDeclaration({
        name: fieldName,
        source,
        target: relatedToEntity,
        isList: Boolean(fieldTypeMeta.array),
        nestedOperations,
        aggregate,
        isNullable: !fieldTypeMeta.required,
        description: field.description?.value,
        args: (0, parse_attribute_1.parseAttributeArguments)(field.arguments || [], definitionCollection),
        annotations,
        relationshipImplementations,
        firstDeclaredInTypeName,
    });
}
function generateConcreteEntity(definition, definitionCollection) {
    const fields = (definition.fields || []).map((fieldDefinition) => {
        // If the attribute is the private directive then
        const isPrivateAttribute = (0, utils_2.findDirective)(fieldDefinition.directives, directives_1.privateDirective.name);
        if (isPrivateAttribute) {
            return;
        }
        const isRelationshipAttribute = (0, utils_2.findDirective)(fieldDefinition.directives, directives_1.relationshipDirective.name);
        if (isRelationshipAttribute) {
            return;
        }
        return (0, parse_attribute_1.parseAttribute)(fieldDefinition, definitionCollection, definition.fields);
    });
    // schema configuration directives are propagated onto concrete entities
    const schemaDirectives = definitionCollection.schemaExtension?.directives?.filter((x) => (0, is_in_array_1.isInArray)(library_directives_1.SCHEMA_CONFIGURATION_OBJECT_DIRECTIVES, x.name.value));
    const annotations = (0, parse_annotation_1.parseAnnotations)((definition.directives || []).concat(schemaDirectives || []));
    return new ConcreteEntity_1.ConcreteEntity({
        name: definition.name.value,
        description: definition.description?.value,
        labels: getLabels(definition),
        attributes: (0, utils_1.filterTruthy)(fields),
        annotations,
    });
}
function getLabels(entityDefinition) {
    const nodeDirectiveUsage = (0, utils_2.findDirective)(entityDefinition.directives, directives_1.nodeDirective.name);
    if (nodeDirectiveUsage) {
        const nodeArguments = (0, parse_arguments_1.parseArguments)(directives_1.nodeDirective, nodeDirectiveUsage);
        if (nodeArguments.labels?.length) {
            return nodeArguments.labels;
        }
    }
    return [entityDefinition.name.value];
}
function generateOperation(definition, definitionCollection) {
    const { attributes, userResolvedAttributes } = (definition.fields || [])
        .map((fieldDefinition) => (0, parse_attribute_1.parseAttribute)(fieldDefinition, definitionCollection))
        .reduce((acc, attribute) => {
        if (attribute.annotations.cypher) {
            acc.attributes.push(attribute);
        }
        else {
            acc.userResolvedAttributes.push(attribute);
        }
        return acc;
    }, { attributes: [], userResolvedAttributes: [] });
    return new Operation_1.Operation({
        name: definition.name.value,
        attributes,
        userResolvedAttributes,
        annotations: (0, parse_annotation_1.parseAnnotations)(definition.directives || []),
    });
}
//# sourceMappingURL=generate-model.js.map