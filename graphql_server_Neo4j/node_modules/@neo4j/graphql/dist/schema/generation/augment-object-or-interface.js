"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.augmentObjectOrInterfaceTypeWithConnectionField = exports.augmentObjectOrInterfaceTypeWithRelationshipField = void 0;
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const graphql_1 = require("graphql");
const constants_1 = require("../../constants");
const QueryOptions_1 = require("../../graphql/input-objects/QueryOptions");
const UnionEntityAdapter_1 = require("../../schema-model/entity/model-adapters/UnionEntityAdapter");
const RelationshipAdapter_1 = require("../../schema-model/relationship/model-adapters/RelationshipAdapter");
const constants_2 = require("../constants");
const directed_argument_1 = require("../directed-argument");
const pagination_1 = require("../pagination");
const to_compose_1 = require("../to-compose");
const connection_where_input_1 = require("./connection-where-input");
const sort_and_options_input_1 = require("./sort-and-options-input");
const utils_1 = require("./utils");
function augmentObjectOrInterfaceTypeWithRelationshipField({ relationshipAdapter, userDefinedFieldDirectives, subgraph, features, composer, }) {
    const fields = {};
    const relationshipField = {
        type: relationshipAdapter.operations.getTargetTypePrettyName(),
        description: relationshipAdapter.description,
        directives: (0, to_compose_1.graphqlDirectivesToCompose)(userDefinedFieldDirectives.get(relationshipAdapter.name) || []),
    };
    let generateRelFieldArgs = true;
    // Subgraph schemas do not support arguments on relationship fields (singular)
    if (subgraph) {
        if (!relationshipAdapter.isList) {
            generateRelFieldArgs = false;
        }
    }
    if (generateRelFieldArgs) {
        const relationshipTarget = relationshipAdapter instanceof RelationshipAdapter_1.RelationshipAdapter && relationshipAdapter.originalTarget
            ? relationshipAdapter.originalTarget
            : relationshipAdapter.target;
        const optionsTypeName = relationshipTarget instanceof UnionEntityAdapter_1.UnionEntityAdapter
            ? QueryOptions_1.QueryOptions
            : relationshipTarget.operations.optionsInputTypeName;
        const whereTypeName = relationshipTarget.operations.whereInputTypeName;
        const nodeFieldsArgs = {
            where: whereTypeName,
            limit: "Int",
            offset: "Int",
        };
        if (!(relationshipTarget instanceof UnionEntityAdapter_1.UnionEntityAdapter)) {
            const sortConfig = (0, sort_and_options_input_1.makeSortInput)({
                entityAdapter: relationshipTarget,
                userDefinedFieldDirectives: new Map(),
                composer,
            });
            if (sortConfig) {
                nodeFieldsArgs["sort"] = sortConfig.NonNull.List;
            }
        }
        // SOFT_DEPRECATION: OPTIONS-ARGUMENT
        if ((0, utils_1.shouldAddDeprecatedFields)(features, "deprecatedOptionsArgument")) {
            nodeFieldsArgs["options"] = {
                type: optionsTypeName,
                directives: [constants_2.DEPRECATE_OPTIONS_ARGUMENT],
            };
        }
        if (relationshipAdapter instanceof RelationshipAdapter_1.RelationshipAdapter) {
            const directedArg = (0, directed_argument_1.getDirectedArgument)(relationshipAdapter, features);
            if (directedArg) {
                nodeFieldsArgs["directed"] = directedArg;
            }
        }
        relationshipField.args = nodeFieldsArgs;
    }
    if (relationshipAdapter.isReadable()) {
        fields[relationshipAdapter.name] = relationshipField;
    }
    return fields;
}
exports.augmentObjectOrInterfaceTypeWithRelationshipField = augmentObjectOrInterfaceTypeWithRelationshipField;
function augmentObjectOrInterfaceTypeWithConnectionField(relationshipAdapter, userDefinedFieldDirectives, schemaComposer, features) {
    const fields = {};
    const deprecatedDirectives = (0, to_compose_1.graphqlDirectivesToCompose)((userDefinedFieldDirectives.get(relationshipAdapter.name) || []).filter((directive) => directive.name.value === constants_1.DEPRECATED));
    const composeNodeArgs = (0, directed_argument_1.addDirectedArgument)({
        where: (0, connection_where_input_1.makeConnectionWhereInputType)({
            relationshipAdapter,
            composer: schemaComposer,
            features,
        }),
        first: {
            type: graphql_1.GraphQLInt,
        },
        after: {
            type: graphql_1.GraphQLString,
        },
    }, relationshipAdapter, features);
    const connectionSortITC = (0, connection_where_input_1.withConnectionSortInputType)({
        relationshipAdapter,
        composer: schemaComposer,
    });
    if (connectionSortITC) {
        composeNodeArgs.sort = connectionSortITC.NonNull.List;
    }
    if (relationshipAdapter.isReadable()) {
        fields[relationshipAdapter.operations.connectionFieldName] = {
            type: (0, connection_where_input_1.withConnectionObjectType)({
                relationshipAdapter,
                composer: schemaComposer,
            }).NonNull,
            args: composeNodeArgs,
            directives: deprecatedDirectives,
            resolve: (source, args, _ctx, info) => {
                return (0, pagination_1.connectionFieldResolver)({
                    connectionFieldName: relationshipAdapter.operations.connectionFieldName,
                    args,
                    info,
                    source,
                });
            },
        };
    }
    return fields;
}
exports.augmentObjectOrInterfaceTypeWithConnectionField = augmentObjectOrInterfaceTypeWithConnectionField;
//# sourceMappingURL=augment-object-or-interface.js.map