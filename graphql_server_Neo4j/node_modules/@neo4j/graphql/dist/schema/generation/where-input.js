"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.withConnectWhereFieldInputType = exports.withSourceWhereInputType = exports.withWhereInputType = exports.addLogicalOperatorsToWhereInputType = exports.withUniqueWhereInputType = void 0;
const graphql_1 = require("graphql");
const ConcreteEntityAdapter_1 = require("../../schema-model/entity/model-adapters/ConcreteEntityAdapter");
const InterfaceEntityAdapter_1 = require("../../schema-model/entity/model-adapters/InterfaceEntityAdapter");
const UnionEntityAdapter_1 = require("../../schema-model/entity/model-adapters/UnionEntityAdapter");
const RelationshipAdapter_1 = require("../../schema-model/relationship/model-adapters/RelationshipAdapter");
const constants_1 = require("../constants");
const get_where_fields_1 = require("../get-where-fields");
const aggregate_types_1 = require("./aggregate-types");
const augment_where_input_1 = require("./augment-where-input");
const utils_1 = require("./utils");
function isEmptyObject(obj) {
    return !Object.keys(obj).length;
}
function withUniqueWhereInputType({ concreteEntityAdapter, composer, features, }) {
    const uniqueWhereFields = {};
    for (const attribute of concreteEntityAdapter.uniqueFields) {
        if ((0, utils_1.shouldAddDeprecatedFields)(features, "implicitEqualFilters")) {
            uniqueWhereFields[attribute.name] = {
                type: attribute.getFieldTypeName(),
                directives: [constants_1.DEPRECATE_IMPLICIT_EQUAL_FILTERS],
            };
        }
        uniqueWhereFields[`${attribute.name}_EQ`] = {
            type: attribute.getFieldTypeName(),
        };
    }
    const uniqueWhereInputType = composer.createInputTC({
        name: concreteEntityAdapter.operations.uniqueWhereInputTypeName,
        fields: uniqueWhereFields,
    });
    return uniqueWhereInputType;
}
exports.withUniqueWhereInputType = withUniqueWhereInputType;
function addLogicalOperatorsToWhereInputType(type) {
    type.addFields({
        OR: type.NonNull.List,
        AND: type.NonNull.List,
        NOT: type,
    });
}
exports.addLogicalOperatorsToWhereInputType = addLogicalOperatorsToWhereInputType;
function withWhereInputType({ entityAdapter, userDefinedFieldDirectives, features, composer, typeName = entityAdapter.operations.whereInputTypeName, returnUndefinedIfEmpty = false, alwaysAllowNesting, ignoreCypherFieldFilters = false, }) {
    if (composer.has(typeName)) {
        return composer.getITC(typeName);
    }
    const whereFields = makeWhereFields({
        entityAdapter,
        userDefinedFieldDirectives,
        features,
        ignoreCypherFieldFilters,
    });
    if (returnUndefinedIfEmpty && isEmptyObject(whereFields)) {
        return undefined;
    }
    const whereInputType = composer.createInputTC({
        name: typeName,
        fields: whereFields,
    });
    const allowNesting = alwaysAllowNesting ||
        entityAdapter instanceof ConcreteEntityAdapter_1.ConcreteEntityAdapter ||
        entityAdapter instanceof RelationshipAdapter_1.RelationshipAdapter ||
        entityAdapter instanceof InterfaceEntityAdapter_1.InterfaceEntityAdapter;
    if (allowNesting) {
        addLogicalOperatorsToWhereInputType(whereInputType);
    }
    if (entityAdapter instanceof ConcreteEntityAdapter_1.ConcreteEntityAdapter && entityAdapter.isGlobalNode()) {
        whereInputType.addFields({ id: graphql_1.GraphQLID });
    }
    if (entityAdapter instanceof InterfaceEntityAdapter_1.InterfaceEntityAdapter) {
        const enumValues = Object.fromEntries(entityAdapter.concreteEntities.map((concreteEntity) => [
            concreteEntity.name,
            { value: concreteEntity.name },
        ]));
        if (entityAdapter.concreteEntities.length > 0) {
            const interfaceImplementation = composer.createEnumTC({
                name: entityAdapter.operations.implementationEnumTypename,
                values: enumValues,
            });
            whereInputType.addFields({ typename_IN: { type: interfaceImplementation.NonNull.List } });
        }
    }
    return whereInputType;
}
exports.withWhereInputType = withWhereInputType;
function makeWhereFields({ entityAdapter, userDefinedFieldDirectives, features, ignoreCypherFieldFilters, }) {
    if (entityAdapter instanceof UnionEntityAdapter_1.UnionEntityAdapter) {
        const fields = {};
        for (const concreteEntity of entityAdapter.concreteEntities) {
            fields[concreteEntity.name] = concreteEntity.operations.whereInputTypeName;
        }
        return fields;
    }
    return (0, get_where_fields_1.getWhereFieldsForAttributes)({
        attributes: entityAdapter.whereFields,
        userDefinedFieldDirectives,
        features,
        ignoreCypherFieldFilters,
    });
}
function withSourceWhereInputType({ relationshipAdapter, composer, deprecatedDirectives, userDefinedDirectivesOnTargetFields, features, }) {
    const relationshipTarget = relationshipAdapter.target;
    const relationshipSource = relationshipAdapter.source;
    const whereInput = composer.getITC(relationshipSource.operations.whereInputTypeName);
    const fields = (0, augment_where_input_1.augmentWhereInputTypeWithRelationshipFields)(relationshipAdapter, deprecatedDirectives);
    whereInput.addFields(fields);
    const connectionFields = (0, augment_where_input_1.augmentWhereInputTypeWithConnectionFields)(relationshipAdapter, deprecatedDirectives);
    whereInput.addFields(connectionFields);
    // TODO: Current unions are not supported as relationship targets beyond the above fields
    if (relationshipTarget instanceof UnionEntityAdapter_1.UnionEntityAdapter) {
        return;
    }
    const whereAggregateInput = (0, aggregate_types_1.withAggregateInputType)({
        relationshipAdapter,
        entityAdapter: relationshipTarget,
        composer: composer,
        userDefinedDirectivesOnTargetFields,
        features,
    });
    if (relationshipAdapter.isFilterableByAggregate()) {
        whereInput.addFields({
            [relationshipAdapter.operations.aggregateTypeName]: {
                type: whereAggregateInput,
                directives: deprecatedDirectives,
            },
        });
    }
    return whereInput;
}
exports.withSourceWhereInputType = withSourceWhereInputType;
function withConnectWhereFieldInputType(relationshipTarget, composer) {
    const connectWhereName = relationshipTarget.operations.connectWhereInputTypeName;
    if (composer.has(connectWhereName)) {
        return composer.getITC(connectWhereName);
    }
    const connectWhereType = composer.createInputTC({
        name: connectWhereName,
        fields: { node: `${relationshipTarget.operations.whereInputTypeName}!` },
    });
    return connectWhereType;
}
exports.withConnectWhereFieldInputType = withConnectWhereFieldInputType;
//# sourceMappingURL=where-input.js.map